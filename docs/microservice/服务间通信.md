---
sidebar: auto
---

# 服务间通信

## 一、服务发现

服务实例具有动态分配的网络位置. 此外, 由于自动扩展, 故障和升级, 实例集合会动态更改, 因此客户端代码必须使用服务发现

 ### 应用层发现模式

 常用的应用层服务发现组件如eureka,nacos

 - 服务机器客户端直接与服务注册表交互
 - 通过部署基础设施来时间服务发现

 ### 平台服务发现模式

 现代部署平台中内置服务注册表和服务发现机制. 如docker + k8s

 部署平台中的注册器观察服务实例, 为其分配DNS名称, 虚拟IP(VIP)和解析为VIP的DNS名称, 客户端想dns名称和vip发起请求, 部署平台自动将请求路由到其中一个可用的服务实例.

 优点是服务发现的所有方面完全由部署平台处理, 服务和客户端都不包含任何服务发现代码. 对语言和框架没有限制

## 二、基于同步的远程过程调用模式的通信

### REST

REST是一种(总是)使用http协议的进程间通讯机制, 关键概念是资源, 采用http动词操作资源.

#### 成熟度模型(从低到高)

1. 客户端只是向服务端发起POST请求, 进行服务调用, 每个请求都指明了需要执行的操作和这个操作针对的目标
2. 要执行对资源的操作, 客户端需要发出指定要执行的操作和包含任何参数的POST的请求
3. 使用HTTP动词进行操作
4. 基于HATEOAS(hypertext as the engine of application state) 设计原则, 基本思想是在由GET请求返回的资源中包含链接, 这些连接能够执行该资源允许的操作

#### 定义

将操作映射为HTTP动词

```js
    POST: /user  	新建用户
    GET: /user/id 	获取某个用户信息
    DELETE: /user/id 	删除某个用户
    PUT:/user    	修改某个用户信息
```
    
#### 弊端

- 只支持请求/响应的通信
- 可能导致可用性降低. 由于客户端和服务端直接通信没有代理缓冲消息, 因此必须保证双方在调用期间都在线
- 客户端必须知道服务实例的位置
- 单个请求中获取多个资源具有挑战性
- 将多个更新操作映射到HTTP动词困难


    
### gRPC

gRPC可以是REST的替代品

gRPC是一种基于二进制消息的协议.

gRPC API 由一个或多个服务和请求/响应消息定义组成, 服务定义类似于JAVA接口, 是强类型方法的集合

gRPC使用Protocol Buffers作为消息格式, 这是一种高效且紧凑的二进制格式, 是一种标记格式
> Protocol Buffers消息的每个字段都有编号, 并且有一个类型代码
>
>消息接收方可以提起所需字段, 并跳过他无法识别的字段, 因此gRPC能够保持向后兼容的同时进行变更

#### 好处

- 设计具有复杂更新操作的API非常简单
- 具有高效, 紧凑的进程间通信机制, 尤其是在交换大量消息时
- 支持在远程过程调用和消息传递过程中使用双向流式消息方式
- 实现了客户端和各种语言编写的服务端之间的互操作性

#### 弊端

- 与基于REST/JSON的API机制相比, js客户端使用基于gRPC的API需要更多的操作
- 旧式防火墙可能不支持HTTP/2

### 处理服务端无响应故障

- 断路器模式

> 监控客户端发出请求的成功和失败数量, 失败比例超过一定阈值后启动断路器, 让后续调用立刻失效, 进过一定时间后客户端应该继续尝试, 如果调用成功, 解除断路器. 常用的断路器: Spring Cloud Hystrix

- 网络超时

> 不要做成无限阻塞, 要设置timeout

- 限制客户端请求数量

> 把客户端能够向特定服务发起的请求设置一个上线, 若请求达到上限, 请求立刻失败. 常见的手段: 令牌桶

- 从服务失效故障中恢复

> 服务只需向其他客户端返回错误
>
> 返回备用值(默认值或者缓存响应). 如果查询操作中存在调用多个服务的场景, 每个服务的数据对客户来说重要性不同, 重要数据应返回其数据的缓存版本或错误; 非重要数据可以返回缓存版本或直接忽略.

## 三、基于异步消息模式的通信

