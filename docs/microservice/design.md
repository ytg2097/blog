---
next: ./split
prev: ./
sidebar: auto
---

# 服务设计

本文内容可在《微服务架构设计模式》一书中找到出处.

## 模式与模式语言

**模式是针对特定上下文中发生的问题的可重用解决方案.**

#### 常用的模式结构三部分

- 需求

> 必须解决的问题, 描述了必须解决的问题与围绕这个问题的特定上下文环境

- 结果上下文

> 1. 采用上下文可能带来的后果
> 2. 好处: 这个模式的好处与解决了什么问题
> 3. 弊端: 这个模式的弊端和没有解决的需求
> 4. 问题: 使用这个模式带来的新问题

- 相关模式

> **前导**: 催生这个模式的需求的模式. 例:微服务模式是单体架构模式之外的所有模式的前导模式
>
> **后续**: 用来解决当前模式引入的新问题的模式. 例: 引入微服务架构模式后, 需要一系列后续模式解决服务发现, 熔断等微服务带来的新问题
>
> **替代**: 当前模式的替代模式, 提供另外的解决方案. 例: 单体模式与微服务模式是互为替代的模式, 都是应用的架构风格.
>
> **泛化**: 解决统一领域问题的所有模式
>
> **特化**: 一个模式可以是另一个模式的特化

#### 模式语言

架构设计的核心是决策, 一个用来表述多种架构设计的选择方案, 并且可用来改进决策的方式就是模式语言, 微服务设计也是一种模式语言.

模式语言是一组模式的集合, 模式语言中的模式共同解决特定领域中的问题. 

微服务架构模式语言是微服务相关联的软件架构和设计模式的集合. 


## 微服务架构模式的后续模式

### 业务逻辑设计模式

- [事务脚本](../ddd/README.md##常见的实现业务的两种方式)
- [领域模型](../ddd/tactics.md)
- [事件溯源](../ddd/event-source.md)

### 服务拆分模式

- 根据业务能力分解模式
- 根据领域建模分解模式

### 服务通信模式

微服务是分布式系统, 进程间通信分为五组模式

- 按通信风格分组. 使用哪一类进程间通信机制
    > 可以是RPC, 也可以是RESTFul, 也可以是消息总线
- 按服务发现分组. 客户端如何获得服务实例的IP
    > 可以是k8s的虚拟ip, 也可以是eureka这样的注册中心
- 按可靠性分组. 在服务不可用情况下, 如何确保服务间的可靠通信
- 事务性消息. 将消息发送,事件发送这样的动作与更新业务数据的数据库事务集成([事务表](../ddd/tactics.md##领域事件))
- 外部API. 客户端与服务见通信.

### 数据一致性模式

- [Saga](./ts.md##Saga)
- [2PC](./ts.md##两阶段提交)
- [TCC](./ts.md##三阶段提交)

### 数据查询的相关模式

- API组合模式. 逐一调用API, 然后聚合结果集
- CQRS命令查询职责分离

### 服务部署的相关模式

- 将服务部署为虚拟机或容器. 最佳
- 采用serverless技术, 只需上传代码, serverless平台自动运行

### 可观测性的相关模式

可观测性的相关模式可以理解和诊断服务运行时的一些行为, 能够根据错误请求或高延迟等故障进行故障排错

- 健康API

    >返回服务健康状态的API
- 日志聚合

    >将服务产生日志写入一个集中式管理的日志服务器, 服务器可以提供搜索, 根据日志情况触发警告
- 分布式追踪 

    >例如链路追踪
- 异常跟踪

    >将异常发送到异常跟踪服务, 这个服务排除重复异常, 给开发者发送警告并跟踪每一个异常的解决
- 应用指标

    >供维护使用的指标, 如计数器, 导出到指标服务器
- 审计日志

    >记录用户行为
    
### 自动化测试相关模式

- 消费端驱动的契约测试

    >验证服务满足客户端所期望的功能
- 消费端契约测试

    >验证服务的客户端可以正常与服务通信

- 服务组建测试

    >在隔离环境中测试服务
    
### 解决基础设施和边界问题的相关模式

微服务架构中, 每个服务都要实现许多跟基础设施相关的功能, 如链路追中, 服务发现等, 可以采用微服务基底模式. 如maven的arichtype

### 安全相关模式

用户身份验证由API Gateway完成, 通过JWT将身份信息传递, 这种方式即令牌访问模式            


## 扩展立方体模型

- X轴(多实例扩展)
    多个相同的实例进行请求路由
    
- Y轴(多服务扩展)
    根据功能将应用拆分成服务
   
- Z轴(数据分区存储扩展)
    根据请求属性进行路由
    
**XZ轴扩展了应用的吞吐量与可用性, Y轴解决了功能性扩展**
