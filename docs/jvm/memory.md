---
prev: ./
next: ./gc
sidebar: auto
---

# 内存区域与内存溢出

## JVM的运行时内存区域

![jvm-memory](../.vuepress/images/jvm-memory.png)

### 堆

jvm的堆内存是线程共享的, 用于存放对象实例, 是垃圾收集器管理的主要收集区域, 由于垃圾收集器采用分代算法, 所以堆又分为新生代与老年代. 详见[GC](./gc.md)

### 虚拟机栈

虚拟机栈描述的是java方法执行的内存模型, 栈是线程私有的, 线程中每个方法执行的时候会压入一个栈帧, 用于存储局部变量表, 操作数栈, 动态连接, 方法出口等信息.

### 本地方法栈 

本地方法栈与虚拟机栈相似, 也是线程私有的, 里面的栈帧是虚拟机使用到的native方法服务

### 方法区

方法区域与堆一样是线程共享的, 用于存储虚拟机加载的Class信息, 常量, 静态变凉, 即时编译器编译后的代码.

方法区又称为永久代, 原因是hotspot虚拟机将GC分代回收扩展至方法区, 或者说使用永久代实现方法区, 目的是让垃圾回收器可以向管理堆一样管理方法区. 

永久代在JDK1.8及以后移除, 使用元空间代替.

#### 运行时常量池

运行时常量池位于方法区内, 用于存放编译器生成的各种字面量和符号引用, 这部分内容在类加载后进入方法区的运行时常量池

::: tip 字面量
文本字符串, 声明为final的常量值
:::

::: tip 符号引用
- 类和接口的完全限定名
- 字段的名称和描述符
- 方法的名称和描述符
:::

### 程序计数器

程序计数器是线程私有的, 它可以看作是当前线程所执行字节码的行号指示器, 字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令. 它用于多线程切换后能够恢复到正确的执行位置. 

## 对象创建过程

1. 虚拟机遇到new命令时, 首先检查这个指令的参数是否能在常量池定位到一个类的符号引用, 并检查这个符号引用代表的类是否已经被加载, 解析和初始化过.
2. 分配内存. 对象所需内存的大小在类加载时就已经确定
3. 初始化分配的内存空间为零值.
4. 虚拟机对对象进行必要的设置. 例如这个对象是哪个类的实例, 如何才能找到对象的元数据信息, 对象的哈希码, 对象的GC分代年龄等信息. 这些信息保存在对象头中
5. 对于虚拟机来说, 前四步已经完成了对象的创建. 执行init方法

## 对象的内存布局

- **对象头**

存储对象自身的运行时数据. 如哈希码, GC分代年龄, 锁状态标志, 偏向线程ID, 偏向时间戳等.

存储类型指针, 即对象指向他的类元数据的指针, 虚拟机通过这个指针来确定这个对象是哪个类的实例(并不是所有虚拟机都这么做), 若对象是数组, 对象头中还需要一块用于记录数组的长度
- **实例数据**

对象真正存储的有效信息, 字段内容, 包括继承的.
- **对齐填充**

由于hotspot的自动内存管理系统要求对象的大小必须是8字节的整数倍, 而对象头部分正好是8字节的整数倍, 因此, 当实例数据没有对齐时, 需要对齐填充来补全.

## 对象的访问定位

java程序通过栈上的reference数据来操作堆上的具体对象, 但虚拟机规范并没有定义这个引用应该通过何种方式去访问堆中的对象, 现在的访问方式有两种:

- **句柄**

堆中划分出一块内存作为句柄池, reference中存储的是对象句柄的地址.

句柄中包含对象实例和类型数据各自的具体地址信息.

好处是当对象被移动时, 只会改变句柄中的实例数据指针, reference本身不需要修改.
- **直接指针**

reference中直接存储对象地址, 好处是访问速度快.

## 内存溢出

内存溢出与内存泄露的区别: 内存溢出程序运行过程中申请的内存大于系统能够提供的内存, 导致无法申请到足够的内存, 于是发生内存溢出. 内存泄露指程序运行过程中分配内存给临时变量, 用完之后却没有GC回收, 始终占用着内存, 
既不能被使用也不能分配给其他程序.

下面记录了几种内存溢出的排查与解决方法

- **堆上的内存溢出**

使用内存映像工具对dump出的堆转储快照进行分析, 确认内存中的对象是否必要, 也就是先分清楚是出现了内存泄露还是内存溢出.

如果是内存泄露, 查看泄露对象到GC Roots的引用链. 

如果不存在内存泄露, 检查堆参数与物理机器对比是否还可以调大, 再检查代码是否某些对象的生命周期过长, 持有状态时间过长.

- **栈上的内存溢出**

主要检查多线程时的溢出, 虚拟机内存排除掉堆和方法区后, 每个线程分配到的栈容量越大, 可以创建的线程数量越少, 创建线程时越容易把剩下的内存耗尽. 
- **方法区的内存溢出**

在经常动态生成大量class的应用中, 需要特别注意类的回收状况. 

如果是JSP或动态生成JSP的应用同上.
